<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src=" https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js "></script>
    <title>Interactive Race Planner</title>
</head>

<body>
    <div class="not-dark h-full w-full">
        <button id="reset">Reset</button>
        <button id="copy-json">Copy JSON</button>
        <button id="copy-csv">Copy CSV</button>
        <button id="import-json">Import JSON</button>
        <div id="message" class="invisible">messages</div>

        <div id="timeline-container"></div>

        <div class="p-4">
            <div>
                <label for="race-distance">Distance:</label>
                <input type="text" id="race-distance"></input>
            </div>
            <div>
                <label for="race-duration">Duration:</label>
                <input type="text" id="race-duration"></input>
            </div>
        </div>

        <div class="p-3" id="table-container"></div>
    </div>

    <script>
        let appData = {};

        function resetData() {
            localStorage.removeItem("race_data");
            loadData();
            render();
            updateControls();
        }

        document.getElementById("reset").addEventListener("click", resetData);

        const loadData = () => {
            let s = localStorage.getItem("race_data");
            if (s == null)
                s = `{
  "formatVersion": "1",
  "raceDistance": "10km",
  "raceDuration": "1:00:00",
  "points": [
    {
      "label": "Start",
      "position": "0km",
      "start": "10min",
      "duration": "30min",
      "color": "#ff0000",
      "track": 2,
      "notes": ""
    },
    {
      "label": "Water Station 1",
      "position": "5km",
      "start": "",
      "duration": "",
      "track": 2,
      "notes": ""
    },
    {
      "label": "Water Station 2",
      "position": "1h",
      "start": "",
      "duration": "",
      "track": 2,
      "notes": ""
    },
    {
      "label": "Finish",
      "position": "10km",
      "start": "",
      "duration": "",
      "track": 2,
      "notes": ""
    }
  ]
}`;
            appData = JSON.parse(s);
        };

        const margin = { top: 50, right: 100, bottom: 30, left: 30 };
        const width = window.innerWidth - margin.left - margin.right;
        const height = 200 - margin.top - margin.bottom;

        const svg = d3
            .select("#timeline-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        function dd(i) {
            return i.toString().padStart(2, "0");
        }

        const tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("visibility", "hidden")
            .style("background", "lightsteelblue")
            .style("padding", "5px")
            .style("border-radius", "4px");

        function save() {
            const s = JSON.stringify(appData);
            console.log('saving', appData);
            localStorage.setItem("race_data", s);
        }

        function raceDistance() {
            const [d, err] = parseDistance(appData.raceDistance);
            if (err != '') {
                d = 1000;
                console.error(err);
            }
            return d;
        }

        function raceDuration() {
            const [d, err] = parseTime(appData.raceDuration);
            if (err != '') {
                d = 100;
                console.error(err);
            }
            return d;
        }

        function formatHHMM(sec) {
            const m = Math.round(sec / 60);
            return `${dd(Math.floor(m / 60))}:${dd(m % 60)}`;
        }

        function markers() {
            return appData.points.map((s) => {
                d = { ...s };
                const e = parseDistanceOrTime(d.position);
                d.distance = e.distance;
                d.time = e.time;
                d.rangeStart = parseDistanceOrTime(d.start);
                d.rangeDuration = parseDistanceOrTime(d.duration);
                return d;
            })
        }

        function render() {
            svg.selectAll("circle").remove();
            svg.selectAll("text").remove();
            svg.selectAll("g").remove();
            svg.selectAll("rect").remove();
            const data = markers();
            console.log('markers', data);

            // Scales will be updated in `render()` based on current data.
            const xScale = d3.scaleLinear()
                .domain([0, Math.max(raceDistance(), d3.max(data, (d) => d.distance))])
                .range([0, width]);
            const timeScale = d3.scaleLinear()
                .domain([0, Math.max(raceDuration(), d3.max(data, (d) => d.time))])
                .range([0, width]);

            const trackHeight = 20;

            // Periods, before markers to make all markers interactive.
            svg
                .selectAll("rect")
                .data(data.filter((d) => d.rangeDuration.distance > 0))
                .enter()
                .append("rect")
                .attr("x", (d) => xScale(d.distance + d.rangeStart.distance))
                .attr("y", (d) => height / 2 + (d.track - 2 - 0.5) * trackHeight)
                .attr("width", (d) => xScale(d.rangeDuration.distance)) // The width depends on start and end
                .attr("height", trackHeight) // Height of the rectangle
                .style("fill", (d) => d.color)
                .style("opacity", 0.5);

            // Add labels
            svg
                .selectAll("text")
                .data(data)
                .enter()
                .append("text")
                .attr("x", (d) => xScale(d.distance) + 10)
                .attr("y", (d) => height / 2 + (d.track - 2) * trackHeight + 6)
                .attr("text-anchor", "left")
                .text((d) => d.label);

            // Markers - created last to make an interactive tooltip.
            svg
                .selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", (d) => xScale(d.distance))
                .attr("cy", (d) => height / 2 + (d.track - 2) * trackHeight)
                .attr("r", 5)
                .style("fill", (d) => d.color)
                .on("mouseover", (event, d) => {
                    tooltip
                        // TODO: format time
                        .html(`${d.label}<br/>${_.round(d.distance / 1000, 2)} km<br/>${formatHHMM(d.time)}<br/>${d.notes}`)
                        .style("visibility", "visible")
                        .style("top", event.pageY - 20 + "px")
                        .style("left", event.pageX + 10 + "px");
                })
                .on("mouseout", () => tooltip.style("visibility", "hidden"));

            // Distance axis.
            svg
                .append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("fill", "black")
                .text("Distance, m");

            // Time axis.
            svg
                .append("g")
                .attr("transform", `translate(0,0)`)
                .call(
                    d3.axisTop(timeScale).tickFormat((d) => formatHHMM(d))
                )
                .append("text")
                .attr("x", width / 2)
                .attr("y", -30)
                .attr("text-anchor", "middle")
                .attr("fill", "black")
                .text("Time, hh:mm");
        }

        function updateControls() {
            document.getElementById("race-distance").value = appData.raceDistance;
            document.getElementById("race-duration").value = appData.raceDuration;

            const tableContainer = document.getElementById("table-container");
            tableContainer.innerHTML = ""; // Clear previous content

            const table = document.createElement("table");
            table.classList.add("editable-table");

            // Create table header
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            ["", "", "Color", "Track", "Label", "Marker", "Offset", "Duration", "notes"].forEach((header) => {
                const th = document.createElement("th");
                th.textContent = header;
                if (header == "Marker") {
                    const btn = document.createElement("button");
                    btn.innerText = "sort";
                    btn.addEventListener("click", sortPoints);
                    th.appendChild(btn);
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement("tbody");
            const addCellInput = (row, v, set, type = "text") => {
                const td = document.createElement("td");
                const input = document.createElement("input");
                input.type = type;
                input.value = v;
                input.addEventListener("input", (e) => {
                    set(e.target.value);
                    save();
                    render();
                });
                td.appendChild(input);
                row.appendChild(td);
            };
            const addCellTextArea = (row, v, set, type = "text") => {
                const td = document.createElement("td");
                const input = document.createElement("textarea");
                input.type = type;
                input.value = v;
                input.addEventListener("input", (e) => {
                    set(e.target.value);
                    save();
                    render();
                });
                td.appendChild(input);
                row.appendChild(td);
            };
            const addCellButton = (row, label, click) => {
                const td = document.createElement("td");
                const btn = document.createElement("button");
                btn.innerText = label;
                btn.addEventListener("click", click);
                td.appendChild(btn);
                row.appendChild(td);
            };

            appData.points.forEach((d, i) => {
                const row = document.createElement("tr");

                addCellButton(row, "dup", () => {
                    appData.points.push({ ...d });
                    save();
                    render();
                    updateControls();
                    console.log('copy');
                });
                addCellButton(row, "del", () => {
                    appData.points.splice(i, 1);
                    save();
                    render();
                    updateControls();
                    console.log('delete');
                });
                addCellInput(row, d.color, (v) => (d.color = v), "color");
                addCellInput(row, d.track, (v) => (d.track = _.clamp(parseInt(v), 0, 4)), "number");
                addCellInput(row, d.label, (v) => (d.label = v));
                addCellInput(row, d.position, (v) => (d.position = v));
                addCellInput(row, d.start, (v) => (d.start = v));
                addCellInput(row, d.duration, (v) => (d.duration = v));
                addCellTextArea(row, d.notes, (v) => (d.notes = v));
                tbody.appendChild(row);
            });

            const row = document.createElement("tr");
            addCellButton(row, "add", () => {
                addPoint();
                save();
                render();
                updateControls();
            });
            tbody.appendChild(row);

            table.appendChild(tbody);
            tableContainer.appendChild(table);
        }
        const strToMeters = (value, unit) => {
            const val = parseFloat(value);
            switch (unit) {
                case "m":
                    return val; // meters
                case "km":
                    return val * 1000; // kilometers to meters
                case "mi":
                    return val * 1609.34; // miles to meters
                default:
                    return 0;
            }
        };

        function parseDistance(input) {
            input = input.toString().trim();
            const distanceRegex = /^([+-]?\d*\.?\d*) *(m|km|mi)$/; // Matches distances like "12km", "5mi"
            let match = input.match(distanceRegex);
            if (match) {
                const value = match[1];
                const unit = match[2];
                return [strToMeters(value, unit), ""];
            }
            return [0, `cannot parse ${input} as distance, format is <number>(m|km|mi)`];
        }

        function parseTime(input) {
            input = input.toString().trim();
            const timeRegex = /^([+-]?\d*\.?\d*) *(s|sec|min|h)|[+-]?(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?$/; // Matches time like "1.5h", "45min", "01:30"

            // Convert time to seconds
            const convertTimeToSeconds = (value, unit) => {
                const val = parseFloat(value);
                switch (unit) {
                    case "s":
                    case "sec":
                        return val; // seconds
                    case "min":
                        return val * 60; // minutes to seconds
                    case "h":
                        return val * 3600; // hours to seconds
                    default:
                        return 0;
                }
            };

            // Convert hh:mm:ss format to seconds.
            const parseHHMMSS = (hours, minutes, seconds = 0) => {
                return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds);
            };

            let match = input.match(timeRegex);
            if (match) {
                let sec = 0;
                if (match[1]) {
                    // Time in "float h/min/s" format, like "1.5h" or "45min".
                    const value = match[1];
                    const unit = match[2];
                    sec = convertTimeToSeconds(value, unit);
                } else if (match[3] && match[4]) {
                    // Time in "hh:mm" or "hh:mm:ss" format.
                    const hours = match[3];
                    const minutes = match[4];
                    const seconds = match[5] || 0;
                    sec = parseHHMMSS(hours, minutes, seconds);
                    if (input.startsWith("-")) sec *= -1;
                }
                return [sec, ""];
            }
            return [0, `cannot parse '${input}' as time`];
        }

        // TODO Report errors
        function parseDistanceOrTime(input) {
            // Regex to match the input format: "(+-)\d*(.\d*|:\d\d|:\d\d:\d\d)?(m|km|mi|s|h|min)"

            const timeToDistance = (s) => {
                return (s / raceDuration()) * raceDistance();
            };

            const distanceToTime = (d) => {
                return (d / raceDistance()) * raceDuration();
            };

            const [d, err] = parseDistance(input);

            if (err == "") {
                return { time: distanceToTime(d), distance: d };
            }

            const [sec, err2] = parseTime(input);
            if (err2 == "") {
                return { time: sec, distance: timeToDistance(sec) };
            }

            return { time: 0, distance: 0 };
        }

        function sortPoints() {
            appData.points.sort((a, b) =>
                parseDistanceOrTime(a.position).distance - parseDistanceOrTime(b.position).distance
            );
            save();
            updateControls();
        }

        function addPoint() {
            appData.points.push({
                "color": "#000000",
                "position": "0:00",
                "label": `#${appData.points.length + 1}`,
                "notes": "",
                "start": "",
                "duration": "",
                "track": 0
            });
            save();
            render();
            updateControls();
        }

        document.getElementById("race-distance").addEventListener("input", (e) => {
            appData.raceDistance = e.target.value;
            save();
            render();
        });

        document.getElementById("race-duration").addEventListener("input", (e) => {
            appData.raceDuration = e.target.value;
            save();
            render();
        });

        document.getElementById("copy-json").addEventListener("click", () => {
            navigator.clipboard.writeText(JSON.stringify(appData)).then(function () {
                showMessage('Copied JSON to clipboard', 'text-green-600', 3000);
            }).catch(function (error) {
                showError('failed to copy to clipboard');
            });
        });

        document.getElementById("import-json").addEventListener("click", () => {
            const s = prompt("insert one-line JSON");
            if (s == null) return;
            appData = JSON.parse(s);
            save();
            render();
            updateControls();
        });


        function maybeEscapeCSVString(s) {
            let value = String(s || '');
            if (/[",\n]/.test(value)) {
                value = `"${value.replace(/"/g, '""')}"`;
            }
            return value;
        }

        function toCSV() {
            const headers = [
                { label: 'Label', value: 'label' },
                { label: 'Position', value: 'position'},
                { label: 'Position seconds', value: 'time'},
                { label: 'Position meters', value: 'distance'},
                { label: 'Offset', value: 'start' },
                { label: 'Offset seconds', value: 'range_start_time' },
                { label: 'Offset meters', value: 'range_start_distance' },
                { label: 'Duration', value: 'duration' },
                { label: 'Duration seconds', value: 'range_duration_time' },
                { label: 'Duration meters', value: 'range_duration_distance' },
                { label: 'Notes', value: 'notes' },
            ];
            const data = markers();
            // Use lodash to map the points array and append metadata
            const rows = data.map((d) => {
                return { ...d,
                    'range_start_time': _.round(d.rangeStart.time),
                    'range_start_distance': _.round(d.rangeStart.distance),
                    'range_duration_time': _.round(d.rangeDuration.time),
                    'range_duration_distance': _.round(d.rangeDuration.distance),
                 };
            });
            // Generate the CSV string
            const csvRows = [
                headers.map(h => h.label),
                ...rows.map(row => headers.map(h => maybeEscapeCSVString(row[h.value] || '')).join(','))
            ];
            return csvRows.join('\n');
        }

        document.getElementById("copy-csv").addEventListener("click", () => {
            const s = toCSV();
            navigator.clipboard.writeText(s).then(function () {
                showMessage('Copied CSV to clipboard', 'text-green-600', 3000);
            }).catch(function (error) {
                showError('failed to copy to clipboard');
            });
        });

        function showError(err) {
            showMessage(err, 'text-red-600');
        }

        function showMessage(content, classes, timeout=null) {
            const m = document.getElementById('message');
            m.className = classes;
            m.innerText = content;
            if (timeout != null) {
                setTimeout(() => {
                    m.className = 'invisible';
                }, timeout)
            }
        }

        // TODO: move sort button to the Marker column
        // TODO: pace
        // TODO: styling
        // TODO: donation button

        setTimeout(() => {
            loadData();
            render();
            updateControls();
        }, 0);
    </script>
</body>

</html>